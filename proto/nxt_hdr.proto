syntax = "proto3";
package nxthdr;
option go_package = "gitlab.com/nextensio/common/messages/nxthdr";

// *******************NOTE NOTE NOTE NOTE NOTE NOTE***********************
// YOU CANNOT RANDOMLY REARRANGE FIELDS OR DELETE FIELDS OR MODIFY MESSAGE
// NUMBER ASSIGNMENTS FOR EXISTING FIELDS ETC.. THE CODE HERE HAS TO BE
// FORWARD AND BACKWARD (BOTH!) COMPATIBLE
// ***********************************************************************

// The cluster sends a clock sync message to the agents with its time
// (serverTime), agent responds to the mssage with the serverTime and its own
// time clientTime - all times in this file are in nanoseconds after unix epoch
message NxtClockSync {
  uint64 serverTime = 1;
  uint64 clientTime = 2;
}

// traceCtx is the Jaeger traceid (context) from the Uber-Trace-Id HTTP header.
//
// processingDuration is the time that the agent spent processing the flow from
// the first time it received it from the OS till it was sent to the cluster (in
// nsecs)
message NxtTrace {
  string traceCtx = 1;
  uint32 processingDuration = 2;
}

// agent: true if its an agent, false for connector.
//
// userid: username of the agent/connector
//
// uuid: a unique identifier for the agent, if the same userid has multiple
// devices, usually just a uuid.UUID suffices to be unique
//
// accessToken: The token of this user, got after logging into IDP. If its a
// bundle, the token will be a sharedKey generated by the controller
//
// services: the service names advertised by this agent/connector
//
// cluster: If the agent/connector is supposed to connect to a SPECIFIC cluster,
// the cluster field indicates that cluster name
//
// podname: The name of the pod on the cluster that this agent/connector should
// connect to
//
// connectId: Usually the agent/connectors username converted to a value that is
// palatable to various kubernetes entities like istio http header matching
// rules. This value is constructed by the controller
//
// attributes: json string of device attributes such as hostname, model,
// os_xyz: device/operating system details
message NxtOnboard {
  bool agent = 1;
  string userid = 2;
  string uuid = 3;
  string accessToken = 4;
  repeated string services = 5;
  string cluster = 6;
  string podname = 7;
  string connectId = 8;
  string attributes = 9;
}

// source, dest, sport, dport, proto: standard five tuple associated with any
// flow. destSvc is the service name - like dest can be google IP say 1.1.1.1
// and destSvc can be "google.com"
//
// sourceAgent: the service name of the source agent/connector that can be used
// in the return direction to get back to the same agent/connector
//
// destAgent: the service name of the dest agent/connector. This field may (or
// may not) be the same as the "destSvc" field. For example if the destSvc field
// is a private service like kismis.org, the destAgent will be the same as
// kismis.org. But if the destSvc field is say google.com, then the destAgent
// can be set to say default-internet. In other words, destAgent gives the
// sender (agent/connector) flexibility to either say "route to whoever provides
// flow.dest" by setting flow.destAgent same as flow.dest OR to say "route
// exactly to this particular service" by setting a specific value for
// flow.destAgent different from flow.dest. The cluster always routes based on
// flow.destAgent field
//
// agentUuid: The unique id of the agent originating the flow. This is used only
// in clusters and connectors, agents and connectors dont fill it or use it
//
// type: two types of nextensio flows - raw l3 packets, tcp/udp terminated l4
//
// usrattr: set of extra attributes for the flow - typically filled in the
// cluster after OPA lookup This is used only in clusters. Agents and connector
// dont fill it or use it
//
// responseData: This indicates the direction of the data. The first data that
// creates the flow is considered the request and the opposite direction is
// considered response. Agents dont fill this, connectors do fill this depending
// on whether the flow is originated from the connector or originated via
// gateway
//
// userCluster and userPod: This is also filled up only by clusters, agents and
// connectors dont have to fill this in. This identifies the "source" cluster
// and pod for the flow, to aid the return path in getting back to the source
//
// userid is same as onboard.userid to propagate the userid along the flow
//
// traceCtx is the Jaeger traceid (context) from the Uber-Trace-Id HTTP header.
//
// traceRequestId is the user's trace request for executing the trace policy.
// It is used to relate the trace spans to the user's trace request
//
// processingDuration is the time that the agent spent processing the flow from
// the first time it received it from the OS till it was sent to the cluster (in
// nsecs)

message NxtFlow {
  string source = 1;
  string dest = 2;
  string destSvc = 3;
  uint32 sport = 4;
  uint32 dport = 5;
  uint32 proto = 6;
  string sourceAgent = 7;
  string destAgent = 8;
  string agentUuid = 9;
  enum FLOW_TYPE {
    L4 = 0;
    L3 = 1;
  }
  FLOW_TYPE type = 10;
  string usrattr = 11;
  bool responseData = 12;
  string userCluster = 13;
  string userPod = 14;
  string userid = 15;
  string traceCtx = 16;
  string traceRequestId = 17;
  uint32 processingDuration = 18;
}

message NxtKeepalive {}

message NxtClose {}

// datalen: if there is raw data that follows this header, the size of raw data
// in bytes
//
// streamid: an identifier that helps multiplex multiple streams in one session
//
// oneof hdr: The header can be ONE of many different types based on what info
// it carries
message NxtHdr {
  uint32 datalen = 1;
  uint64 streamid = 2;
  oneof hdr {
    NxtClose close = 3;
    NxtOnboard onboard = 4;
    NxtFlow flow = 5;
    NxtKeepalive keepalive = 6;
    NxtTrace trace = 7;
    NxtClockSync sync = 8;
  }
}
